/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Store = __webpack_require__(2);
var Model = __webpack_require__(3);

var itemTpl = doT.template(
	document.getElementById('todo-list-item').innerHTML,
);
var itemKeys = 'id title completed'.split(/ /);

module.exports = {
	model: new Model(new Store('todomvc-vce')),
	renderItem: function render(it) {
		render._div = render._div || document.createElement('div');
		render._div.innerHTML = itemTpl(it);

		return render._div.childNodes[0];
	},
	itemSame: function (a, b) {
		return itemKeys.every(function (k) {
			return a[k] === b[k];
		});
	},
	promisify: function (obj, method) {
		return function () {
			var args = [].slice.call(arguments);
			return new Promise(function (resolve) {
				args.push(resolve);
				obj[method].apply(obj, args);
			});
		};
	},
	ENTER_KEY: 13,
	ESCAPE_KEY: 27,
};

VComponent.components = {
	'todo': __webpack_require__(4),
	'todo-header': __webpack_require__(5),
	'todo-footer': __webpack_require__(6),
	'todo-main': __webpack_require__(7),
	'todo-item': __webpack_require__(8),
};

VComponent.render(document).then(function (children) {
	var root = children.filter(function (child) {
		return child.name === 'todo';
	})[0];

	function route() {
		root.routeTo(location.hash.replace(/^[#!]+/, '') || '/');
	}

	window.addEventListener('hashchange', route);
	setTimeout(route);
});



/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = window.VComponent.extend({
	method: function (name) {
		return this[name].bind(this);
	},
});


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// borrow from https://github.com/tastejs/todomvc/blob/gh-pages/examples/vanillajs/js/store.js

/**
 * Creates a new client side storage object and will create an empty
 * collection if no collection already exists.
 *
 * @param {string} name The name of our DB we want to use
 * @param {function} callback Our fake DB uses callbacks because in
 * real life you probably would be making AJAX calls
 */
function Store(name, callback) {
	callback = callback || function () {};

	this._dbName = name;

	if (!localStorage[name]) {
		var data = {
			todos: [],
		};

		localStorage[name] = JSON.stringify(data);
	}

	callback.call(this, JSON.parse(localStorage[name]));
}

/**
 * Finds items based on a query given as a JS object
 *
 * @param {object} query The query to match against (i.e. {foo: 'bar'})
 * @param {function} callback   The callback to fire when the query has
 * completed running
 *
 * @example
 * db.find({foo: 'bar', hello: 'world'}, function (data) {
	 *	 // data will return any items that have foo: bar and
	 *	 // hello: world in their properties
	 * });
 */
Store.prototype.find = function (query, callback) {
	if (!callback) {
		return;
	}

	var todos = JSON.parse(localStorage[this._dbName]).todos;

	callback.call(this, todos.filter(function (todo) {
		for (var q in query) {
			if (query[q] !== todo[q]) {
				return false;
			}
		}
		return true;
	}));
};

/**
 * Will retrieve all data from the collection
 *
 * @param {function} callback The callback to fire upon retrieving data
 */
Store.prototype.findAll = function (callback) {
	callback = callback || function () {};
	callback.call(this, JSON.parse(localStorage[this._dbName]).todos);
};

/**
 * Will save the given data to the DB. If no item exists it will create a new
 * item, otherwise it'll simply update an existing item's properties
 *
 * @param {object} updateData The data to save back into the DB
 * @param {function} callback The callback to fire after saving
 * @param {number} id An optional param to enter an ID of an item to update
 */
Store.prototype.save = function (updateData, callback, id) {
	var data = JSON.parse(localStorage[this._dbName]);
	var todos = data.todos;

	callback = callback || function () {};

	// If an ID was actually given, find the item and update each property
	if (id) {
		for (var i = 0; i < todos.length; i++) {
			if (todos[i].id == id) {
				for (var key in updateData) {
					todos[i][key] = updateData[key];
				}

				localStorage[this._dbName] = JSON.stringify(data);
				callback.call(this, [todos[i]]);
				return;
			}
		}

	} else {
		// Generate an ID
		updateData.id = new Date().getTime();

		todos.push(updateData);
		localStorage[this._dbName] = JSON.stringify(data);
		callback.call(this, [updateData]);
	}
};

/**
 * Will remove an item from the Store based on its ID
 *
 * @param {number} id The ID of the item you want to remove
 * @param {function} callback The callback to fire after saving
 */
Store.prototype.remove = function (id, callback) {
	var data = JSON.parse(localStorage[this._dbName]);
	var todos = data.todos;

	for (var i = 0; i < todos.length; i++) {
		if (todos[i].id == id) {
			todos.splice(i, 1);
			break;
		}
	}

	localStorage[this._dbName] = JSON.stringify(data);
	callback.call(this, todos);
};

/**
 * Will drop all storage and start fresh
 *
 * @param {function} callback The callback to fire after dropping the data
 */
Store.prototype.drop = function (callback) {
	var data = { todos: [] };
	localStorage[this._dbName] = JSON.stringify(data);
	callback.call(this, data.todos);
};

module.exports = Store;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// borrow from https://github.com/tastejs/todomvc/blob/gh-pages/examples/vanillajs/js/model.js

/**
 * Creates a new Model instance and hooks up the storage.
 *
 * @constructor
 * @param {object} storage A reference to the client side storage class
 */
function Model(storage) {
	this.storage = storage;
}

/**
 * Creates a new todo model
 *
 * @param {string} [title] The title of the task
 * @param {function} [callback] The callback to fire after the model is created
 */
Model.prototype.create = function (title, callback) {
	title = title || '';
	callback = callback || function () {};

	var newItem = {
		title: title.trim(),
		completed: false,
	};

	this.storage.save(newItem, callback);
};

/**
 * Finds and returns a model in storage. If no query is given it'll simply
 * return everything. If you pass in a string or number it'll look that up as
 * the ID of the model to find. Lastly, you can pass it an object to match
 * against.
 *
 * @param {string|number|object} [query] A query to match models against
 * @param {function} [callback] The callback to fire after the model is found
 *
 * @example
 * model.read(1, func); // Will find the model with an ID of 1
 * model.read('1'); // Same as above
 * //Below will find a model with foo equalling bar and hello equalling world.
 * model.read({ foo: 'bar', hello: 'world' });
 */
Model.prototype.read = function (query, callback) {
	var queryType = typeof query;
	callback = callback || function () {};

	if (queryType === 'function') {
		callback = query;
		return this.storage.findAll(callback);
	} else if (queryType === 'string' || queryType === 'number') {
		query = parseInt(query, 10);
		this.storage.find({ id: query }, callback);
	} else {
		this.storage.find(query, callback);
	}
};

/**
 * Updates a model by giving it an ID, data to update, and a callback to fire when
 * the update is complete.
 *
 * @param {number} id The id of the model to update
 * @param {object} data The properties to update and their new value
 * @param {function} callback The callback to fire when the update is complete.
 */
Model.prototype.update = function (id, data, callback) {
	this.storage.save(data, callback, id);
};

/**
 * Removes a model from storage
 *
 * @param {number} id The ID of the model to remove
 * @param {function} callback The callback to fire when the removal is complete.
 */
Model.prototype.remove = function (id, callback) {
	this.storage.remove(id, callback);
};

/**
 * WARNING: Will remove ALL data from storage.
 *
 * @param {function} callback The callback to fire when the storage is wiped.
 */
Model.prototype.removeAll = function (callback) {
	this.storage.drop(callback);
};

/**
 * Returns a count of all todos
 */
Model.prototype.getCount = function (callback) {
	var todos = {
		active: 0,
		completed: 0,
		total: 0,
	};

	this.storage.findAll(function (data) {
		data.forEach(function (todo) {
			if (todo.completed) {
				todos.completed++;
			} else {
				todos.active++;
			}

			todos.total++;
		});
		callback(todos);
	});
};

module.exports = Model;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var app = __webpack_require__(0);
var Component = __webpack_require__(1);
var routes = {
	'/': 'all',
	'': 'all',
	'/active': 'active',
	'/completed': 'completed',
};

module.exports = Component.extend({
	init: function () {
		var that = this;

		this.children.header[0].on('enter', this.method('onEnterItem'));
		this.followUpdate('header');
		this.followUpdate('main');
		this.followUpdate('footer');
		this.on('update', this.method('onUpdate'));

		app.model.read(undefined, function (items) {
			that.children.main[0].render(items);
			that.children.footer[0].render(items);
		});
	},
	followUpdate: function (name) {
		this.children[name][0].on('update', this.emit.bind(this, 'update', name));
	},
	routeTo: function (path) {
		if (!routes[path]) {
			location.hash = '/';
			return;
		}

		this.children.main[0].setFilter(routes[path]);
		this.children.footer[0].setFilter(routes[path]);
	},
	onEnterItem: function (title) {
		var that = this;

		this.children.header[0].clear();
		app.model.create(title, function (items) {
			var main = that.children.main[0];
			Promise.all(items.map(main.appendItem.bind(main)))
				.then(that.emit.bind(that, 'update', 'header'));
		});
	},
	onUpdate: function (source) {
		var that = this;
		app.model.read(undefined, function (items) {
			setTimeout(function () {
				if (source !== 'header') {
					that.children.header[0].render(items);
				}
				if (source !== 'main') {
					that.children.main[0].render(items);
				}
				if (source !== 'footer') {
					that.children.footer[0].render(items);
				}
			});
		});
	},
});


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var app = __webpack_require__(0);

module.exports = __webpack_require__(1).extend({
	name: 'header',
	init: function () {
		this.elInput = this.qs('input.new-todo');
	},
	events: [
		'keydown blur/input.new-todo/onInput',
	],
	render: function (items) {
		// var that = this;
		// if (items) {
		// 	paint(items);
		// } else {
		// 	app.model.read(undefined, paint);
		// }
		//
		// function paint(items) {
		// }
	},
	clear: function () {
		this.elInput.value = '';
	},
	onInput: function (event) {
		if (event.keyCode && event.keyCode !== app.ENTER_KEY) return;
		if (!this.elInput.value) return;
		this.emit('enter', this.elInput.value);
	},
});


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var app = __webpack_require__(0);

module.exports = __webpack_require__(1).extend({
	name: 'footer',
	init: function () {
		this.elCounter = this.qs('.todo-count');
		this.elClear = this.qs('.clear-completed');
	},
	events: [
		'click/.clear-completed/onClear',
	],
	render: function (items) {
		var that = this;
		if (items) {
			paint(items);
		} else {
			app.model.read(undefined, paint);
		}

		function paint(items) {
			var left = items.filter(function (item) {
				return !item.completed;
			}).length;
			if (left === 1) {
				that.elCounter.innerHTML = '<strong>1</strong> item left';
			} else {
				that.elCounter.innerHTML = '<strong>' + left + '</strong> items left';
			}

			that.root.style.display = items.length > 0 ? 'block' : 'none';

			that.elClear.style.display = items.some(function (item) {
				return item.completed;
			}) ? 'block' : 'none';
		}
	},
	setFilter: function (type) {
		var that = this;
		this.qsa('[data-route]').forEach(function (el) {
			var method = {
				true: 'add',
				false: 'remove',
			}[el.dataset.route === type];

			el.classList[method]('selected');
		});
	},
	onClear: function () {
		var that = this;
		var remain = false;
		app.model.read(undefined, function (items) {
			Promise
				.all(items.map(function (item) {
					if (!item.completed) {
						remain = true;
						return;
					}
					return app.promisify(app.model, 'remove')(item.id);
				}))
				.then(function () {
					if (!remain) {
						that.root.style.display = 'none';
					}
					that.elClear.style.display = 'none';
					that.emit('update');
				})
			;
		});
	},
});


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var app = __webpack_require__(0);

function isItemFiltered(item, type) {
	if (type === 'active') {
		return !!item.completed;
	} else if (type === 'completed') {
		return !item.completed;
	}
	return false;
}

module.exports = __webpack_require__(1).extend({
	name: 'main',
	init: function () {
		this.elToggleAll = this.qs('input.toggle-all');
		this.elList = this.qs('ul.todo-list');
	},
	events: [
		'change/input.toggle-all/onToggleAll',
	],
	render: function (items) {
		var that = this;
		if (items) {
			paint(items);
		} else {
			app.model.read(undefined, paint);
		}

		function paint(items) {
			var itemObj = {};
			var wait = [];
			var children = (that.children.item || []).slice();

			items.forEach(function (item, idx) {
				var child = children.filter(function (child) {
					return child.getId() == item.id;
				})[0];
				if (child) {
					child.redraw(item);
				} else {
					wait.push(that.appendItem(item));
				}
				itemObj[item.id] = item;
			});

			Promise.all(wait).then(function () {
				(that.children.item || []).slice().forEach(function (child) {
					let id = child.getId();
					if (!itemObj[id]) {
						that.removeChild(child);
					} else if (isItemFiltered(itemObj[id], that.filter)) {
						child.root.classList.add('hide');
					} else {
						child.root.classList.remove('hide');
					}
				});

				that.root.style.display =
					that.children.item && that.children.item.length > 0
						? 'block'
						: 'none';

				that.elToggleAll.checked = items.every(function (item) {
					return item.completed;
				});
			});
		}
	},
	setFilter: function (type) {
		this.filter = type;
		this.render();
	},
	appendItem: function (item, refEl) {
		var that = this;
		var el = app.renderItem(item);
		if (refEl) {
			this.elList.insertBefore(el, refEl);
		} else {
			this.elList.appendChild(el);
		}
		return this.renderChildElement(el).then(function (child) {
			return child.on('destroy update', function () {
				that.render();
				that.emit('update');
			});
		});
	},
	onToggleAll: function (event) {
		var that = this;
		app.model.read(undefined, function (items) {
			var all = items.map(function (item) {
				return app.promisify(app.model, 'update')(item.id, {
					completed: event.target.checked,
				});
			});
			Promise.all(all).then(function () {
				that.render();
				that.emit('update');
			});
		});
	},
});


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var app = __webpack_require__(0);

module.exports = __webpack_require__(1).extend({
	name: 'item',
	init: function () {
		var that = this;
		app.model.read(this.getId(), function (items) {
			that.item = items[0];
		});
	},
	events: [
		'change/.toggle/onToggle',
		'click/.destroy/onDestroy',
		'dblclick/label/onStartEdit',
		'keyup blur/input.edit/onEditing',
	],
	getId: function () {
		return this.root.dataset.itemId;
	},
	redraw: function (item) {
		if (!app.itemSame(item, this.item) || item.editing || this.item.editing) {
			this.replaceRoot(app.renderItem(item));
			this.item = item;
		}
	},
	onDestroy: function (event) {
		var that = this;
		app.model.remove(this.getId(), function () {
			that.emit('destroy');
		});
	},
	onToggle: function (event) {
		var that = this;
		app.model.update(this.getId(), {
			completed: !!event.target.checked,
		}, function (items) {
			that.redraw(items[0]);
			that.emit('update', items[0]);
		});
	},
	onStartEdit: function (event) {
		var that = this;
		app.model.read(this.getId(), function (items) {
			that.redraw(Object.assign({
				editing: true,
			}, items[0]));
			var edit = that.qs('input.edit');
			edit.value = items[0].title;
			edit.focus();
		});
	},
	onEditing: function (event) {
		var that = this;
		if (!event.keyCode) { // blur
			if (!that.iscancel) {
				app.model.update(that.getId(), {
					title: event.target.value,
				}, function (items) {
					that.redraw(items[0]);
					that.emit('update', items[0]);
				});
			} else {
				app.model.read(that.getId(), function (items) {
					that.redraw(items[0]);
				});
				delete that.iscancel;
			}
		} else if (event.keyCode === app.ESCAPE_KEY) {
			that.iscancel = true;
			event.target.blur();
		} else if (event.keyCode === app.ENTER_KEY) {
			event.target.blur();
		}
	},
});


/***/ })
/******/ ]);